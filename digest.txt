Directory structure:
└── backend/
    ├── requirements.txt
    └── app/
        ├── __init__.py
        ├── config.py
        ├── database.py
        ├── dependencies.py
        ├── firewall_driver.py
        ├── firewall_os.py
        ├── linux_firewall.py
        ├── log_watchers.py
        ├── main.py
        ├── middleware.py
        ├── models.py
        ├── schemas.py
        ├── win_firewall.py
        ├── __pycache__/
        └── routers/
            ├── auth.py
            ├── backup.py
            ├── dns.py
            ├── firewall.py
            ├── firewall_groups.py
            ├── layer7_inspect.py
            ├── logs.py
            ├── nat.py
            ├── network.py
            ├── routes.py
            ├── status.py
            └── __pycache__/

================================================
File: requirements.txt
================================================
fastapi==0.95.0
uvicorn==0.22.0
pydantic==1.10.7
python-dotenv==1.0.0
PyJWT==2.6.0
bcrypt==4.0.1
motor==3.7.1

# Test iÃƒÂ§in
pytest==7.3.1
pytest-asyncio==0.21.0
httpx==0.24.0
python-jose==3.3.0
psutil==5.9.5

# Adblock listesi (requests)
requests==2.31.0



================================================
File: app/__init__.py
================================================



================================================
File: app/config.py
================================================
import os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    PROJECT_NAME: str = "KOBI Firewall"
    JWT_SECRET: str = os.getenv("JWT_SECRET", "degistir-bunu")
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    MONGODB_URL: str = os.getenv("MONGODB_URL", "mongodb://localhost:27017")
    DATABASE_NAME: str = "kobi_firewall_db"

settings = Settings()



================================================
File: app/database.py
================================================
from motor.motor_asyncio import AsyncIOMotorClient
from app.config import settings

client = AsyncIOMotorClient(settings.MONGODB_URL)
db = client[settings.DATABASE_NAME]



================================================
File: app/dependencies.py
================================================
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from app.config import settings
from app.database import db

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
    )
    try:
        payload = jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.JWT_ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        user = await db["users"].find_one({"username": username})
        if not user:
            raise credentials_exception
        return user
    except JWTError:
        raise credentials_exception

def require_admin(user=Depends(get_current_user)):
    if user["role"] != "admin":
        raise HTTPException(status_code=403, detail="Admin privileges required")
    return user



================================================
File: app/firewall_driver.py
================================================
class FirewallDriver:
    """
    Ortak (base) bir firewall sÃ¼rÃ¼cÃ¼ sÄ±nÄ±fÄ±.
    Windows veya Linux alt sÄ±nÄ±flar bunu miras alarak
    add_rule, remove_rule, update_rule metodlarÄ±nÄ± uygular.
    """
    def add_rule(self, rule):
        raise NotImplementedError

    def remove_rule(self, rule_name):
        raise NotImplementedError

    def update_rule(self, old_rule, new_rule):
        raise NotImplementedError



================================================
File: app/firewall_os.py
================================================
import platform
from app.linux_firewall import LinuxFirewall
from app.win_firewall import WinFirewall

def remove_firewall_rule_os(rule_name: str):
    sysname = platform.system().lower()
    if sysname.startswith("win"):
        fw = WinFirewall()
        fw.remove_rule(rule_name)
    else:
        fw = LinuxFirewall()
        fw.remove_rule(rule_name)

def add_firewall_rule_os(rule):
    sysname = platform.system().lower()
    if sysname.startswith("win"):
        fw = WinFirewall()
    else:
        fw = LinuxFirewall()
    fw.add_rule(rule)

def update_firewall_rule_os(old_rule, new_rule):
    sysname = platform.system().lower()
    if sysname.startswith("win"):
        fw = WinFirewall()
    else:
        fw = LinuxFirewall()
    fw.update_rule(old_rule, new_rule)



================================================
File: app/linux_firewall.py
================================================
import subprocess
from fastapi import HTTPException
from app.firewall_driver import FirewallDriver

day_mapping = ["MO","TU","WE","TH","FR","SA","SU"]

def build_time_params(rule):
    time_params = []
    if rule.get("schedule_start") and rule.get("schedule_end"):
        start_str = rule["schedule_start"]
        end_str = rule["schedule_end"]
        time_params = ["-m", "time", "--timestart", start_str, "--timestop", end_str]

        if rule.get("days_of_week"):
            valid_days = []
            for d in rule["days_of_week"]:
                if 0 <= d <= 6:
                    valid_days.append(day_mapping[d])
            if valid_days:
                day_str = ",".join(valid_days)
                time_params += ["--days", day_str]
    return time_params

class LinuxFirewall(FirewallDriver):
    def add_rule(self, rule):
        chain = "INPUT" if rule["direction"].upper() == "IN" else "OUTPUT"
        if rule["action"].upper() == "ALLOW":
            target = "ACCEPT"
            log_prefix = None
        else:
            target = "DROP"
            log_prefix = "FWDROP: "

        proto = rule.get("protocol","tcp").lower()
        src_ip = "0.0.0.0/0"
        if rule.get("source_ips"):
            src_ip = rule["source_ips"][0]

        # 1) LOG kuralÄ± (DENY ise)
        if log_prefix:
            log_cmd = [
                "iptables", "-A", chain,
                "-p", proto,
                "-s", src_ip
            ]
            if rule.get("port"):
                if chain == "INPUT":
                    log_cmd += ["--dport", str(rule["port"])]
                else:
                    log_cmd += ["--sport", str(rule["port"])]
            log_cmd += build_time_params(rule)
            log_cmd += [
                "-m", "comment", "--comment", rule["rule_name"],
                "-j", "LOG", "--log-prefix", log_prefix
            ]
            res_log = subprocess.run(log_cmd, capture_output=True, text=True)
            if res_log.returncode != 0:
                raise HTTPException(400, f"Linux firewall add rule LOG error: {res_log.stderr.strip()}")

        # 2) AsÄ±l kural
        ip_cmd = [
            "iptables", "-A", chain,
            "-p", proto,
            "-s", src_ip
        ]
        if rule.get("port"):
            if chain == "INPUT":
                ip_cmd += ["--dport", str(rule["port"])]
            else:
                ip_cmd += ["--sport", str(rule["port"])]

        ip_cmd += build_time_params(rule)
        ip_cmd += [
            "-m", "comment", "--comment", rule["rule_name"],
            "-j", target
        ]

        res = subprocess.run(ip_cmd, capture_output=True, text=True)
        if res.returncode != 0:
            raise HTTPException(400, f"Linux firewall add rule error: {res.stderr.strip()}")

    def remove_rule(self, rule_name):
        # iptables -D ... vs. (henÃ¼z tam uygulanmadÄ±)
        pass

    def update_rule(self, old_rule, new_rule):
        self.remove_rule(old_rule["rule_name"])
        self.add_rule(new_rule)



================================================
File: app/log_watchers.py
================================================
import asyncio
import re
import platform
import subprocess
from datetime import datetime, timedelta

from app.database import db

FWDROP_REGEX = re.compile(r"FWDROP:")

async def iptables_log_watcher():
    """
    Basit bir syslog (tail -F) takibi yaparak 'FWDROP:' prefixli satÄ±rlarÄ±
    blocked_packets koleksiyonuna ekler. Sadece Linux Ã¶rneÄŸi.
    """
    if not platform.system().lower().startswith("linux"):
        return

    cmd = ["tail", "-F", "/var/log/syslog"]
    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )

    while True:
        line = await process.stdout.readline()
        if not line:
            await asyncio.sleep(0.1)
            continue

        if "FWDROP:" in line:
            doc = {
                "timestamp": datetime.utcnow(),
                "raw_log_line": line.strip()
            }
            await db["blocked_packets"].insert_one(doc)

            await check_blocked_alarm()

async def check_blocked_alarm():
    """
    Basit alarm kontrolÃ¼: Son 5 dk iÃ§inde 50'den fazla DROP varsa 'ALERT' log ekler.
    """
    now = datetime.utcnow()
    cutoff = now - timedelta(minutes=5)
    count_last_5min = await db["blocked_packets"].count_documents({"timestamp": {"$gte": cutoff}})

    if count_last_5min > 50:
        alarm_doc = {
            "timestamp": now,
            "level": "ALERT",
            "message": f"Son 5 dakika iÃ§inde {count_last_5min} DROP tespit edildi!"
        }
        await db["logs"].insert_one(alarm_doc)


async def advanced_log_analysis_task():
    """
    Her 5 dakikada bir, 'logs' tablosunda Ã§ok fazla DENY (firewall_rules) varsa alert Ã¼retir.
    Ã–r: son 10 dakikada 100'den fazla DENY log kaydÄ± -> 'alerts' koleksiyonuna ekle
    """
    while True:
        now = datetime.utcnow()
        cutoff = now - timedelta(minutes=10)

        query = {
            "timestamp": {"$gte": cutoff},
            "level": "INFO",
            "message": {"$regex": "DENY|DROP"}
        }
        count_deny = await db["logs"].count_documents(query)

        if count_deny > 100:
            alert_doc = {
                "timestamp": now,
                "level": "ALERT",
                "message": f"Son 10 dk iÃ§inde {count_deny} adet DENY log kaydÄ± tespit edildi!"
            }
            await db["alerts"].insert_one(alert_doc)

        await asyncio.sleep(300)  # 5 dk

async def start_log_watchers():
    asyncio.create_task(iptables_log_watcher())
    asyncio.create_task(advanced_log_analysis_task())



================================================
File: app/main.py
================================================
import asyncio
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.config import settings
from app.middleware import log_requests

# Router importlarÄ±
from app.routers.auth import auth_router
from app.routers.logs import logs_router
from app.routers.status import status_router
from app.routers.network import network_router
from app.routers.nat import nat_router
from app.routers.firewall import firewall_router
from app.routers.backup import backup_router
from app.routers.routes import route_router
from app.routers.firewall_groups import firewall_groups_router
from app.routers.dns import dns_router

from app.log_watchers import iptables_log_watcher

app = FastAPI(title=settings.PROJECT_NAME)

origins = ["http://localhost:3000", "http://127.0.0.1:3000"]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.middleware("http")
async def custom_logging_middleware(request, call_next):
    return await log_requests(request, call_next)

# TÃ¼m router'larÄ± ekle
app.include_router(auth_router)
app.include_router(logs_router)
app.include_router(status_router)
app.include_router(network_router)
app.include_router(nat_router)
app.include_router(firewall_router)
app.include_router(backup_router)
app.include_router(route_router)
app.include_router(firewall_groups_router)
app.include_router(dns_router)

@app.get("/")
def read_root():
    return {"message": "KOBI Firewall API running..."}

@app.on_event("startup")
async def start_log_watchers():
    asyncio.create_task(iptables_log_watcher())



================================================
File: app/middleware.py
================================================
import time
from starlette.requests import Request
from starlette.responses import Response
from app.database import db
from datetime import datetime

async def log_requests(request: Request, call_next):
    start_time = time.time()
    response: Response = await call_next(request)
    process_time = time.time() - start_time

    log_doc = {
        "timestamp": datetime.utcnow(),
        "method": request.method,
        "path": request.url.path,
        "query_string": request.url.query,
        "status_code": response.status_code,
        "process_time_ms": int(process_time * 1000),
        "source_ip": request.client.host,
        "level": "INFO",
        "message": f"Request to {request.url.path}"
    }

    await db["logs"].insert_one(log_doc)
    return response



================================================
File: app/models.py
================================================
from pydantic import BaseModel, Field
from typing import Optional
import datetime

class UserDB(BaseModel):
    id: str = Field(..., alias="_id")
    username: str
    hashed_password: str
    role: str
    created_at: datetime.datetime

class FirewallRuleDB(BaseModel):
    id: str = Field(..., alias="_id")
    rule_name: str
    source_ip: str
    action: str
    created_at: datetime.datetime

class LogEntryDB(BaseModel):
    id: str = Field(..., alias="_id")
    timestamp: datetime.datetime
    level: str
    message: str
    source_ip: Optional[str] = None



================================================
File: app/schemas.py
================================================
from pydantic import BaseModel
from typing import Optional

class UserCreate(BaseModel):
    username: str
    password: str

class UserLogin(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

class FirewallRuleCreate(BaseModel):
    rule_name: str
    source_ip: str
    action: str  # "ALLOW" / "DENY"

class FirewallRuleOut(BaseModel):
    id: str
    rule_name: str
    source_ip: str
    action: str



================================================
File: app/win_firewall.py
================================================
# File: app/win_firewall.py

import subprocess
from fastapi import HTTPException
from app.firewall_driver import FirewallDriver

class WinFirewall(FirewallDriver):
    def add_rule(self, rule):
        """
        Windows PowerShell kullanarak firewall kuralı ekler.
        Birden fazla port veya ANY protokol desteğini ekledik.
        """

        # Action: ALLOW veya DENY -> PS karşılığı "Allow" veya "Block"
        ps_action = "Allow" if rule.get("action", "").upper() == "ALLOW" else "Block"

        # Yön: IN / OUT -> PS karşılığı "Inbound" / "Outbound"
        direction_map = {"IN": "Inbound", "OUT": "Outbound"}
        ps_dir = direction_map.get(rule.get("direction", "").upper(), "Inbound")

        # Kural ismi
        rule_name = rule.get("rule_name", "UnnamedRule")

        # Komutu oluştur
        cmd = f"New-NetFirewallRule -Name '{rule_name}' -DisplayName '{rule_name}'"
        cmd += f" -Direction {ps_dir} -Action {ps_action}"

        # Protokol: TCP / UDP / ANY
        # -Protocol ANY, Windows'ta çalışır (bazı versiyonlarda ANY verince “All” sayılır).
        protocol = rule.get("protocol", "ANY").upper()
        if protocol != "ANY":
            cmd += f" -Protocol {protocol}"
        else:
            # ANY seçilince -Protocol ANY diyebiliriz.
            cmd += " -Protocol ANY"

        # Port bilgisi (birden fazla port girilmiş olabilir, örn: "80,443")
        # AMA "ANY" protokol seçildiyse, Windows'ta port parametresi genelde geçersizdir.
        port_str = rule.get("port")
        if port_str and protocol != "ANY":
            # Kullanıcı virgülle ayırmış olabilir (ör: "80,443").
            # Aradaki boşlukları silelim:
            port_str = str(port_str).replace(" ", "")
            if ps_dir == "Inbound":
                cmd += f" -LocalPort {port_str}"
            else:
                cmd += f" -RemotePort {port_str}"
            # Eğer range girilecekse ("80-90") da bu şekilde geçerli olur.

        # Source IP adres(ler)i (ör: ["10.36.130.28"])
        source_ips = rule.get("source_ips", [])
        if source_ips:
            # virgülle birleştirelim
            ip_list = ",".join(source_ips)
            cmd += f" -RemoteAddress {ip_list}"

        # Profile: "Any" / "Domain" / "Private" / "Public"
        # eğer "Any" girilmişse parametre eklemeye gerek yok diyebiliriz. (Ama biz yine de ekleyebiliriz)
        profile_val = rule.get("profile", "Any")
        if profile_val.lower() != "any":
            # ilk harfi büyük geri kalanı küçük
            cmd += f" -Profile {profile_val.capitalize()}"

        # Açıklama varsa
        description = rule.get("description")
        if description:
            cmd += f" -Description '{description}'"

        # PowerShell komutunu çalıştıralım
        ps_cmd = ["powershell", "-Command", cmd]
        res = subprocess.run(ps_cmd, capture_output=True, text=True)

        if res.returncode != 0:
            # Windows firewall komutundan gelen stderr'i kullanıcıya gösteriyoruz
            error_msg = res.stderr.strip()
            raise HTTPException(400, f"Windows firewall add rule error: {error_msg}")

        # Kural eklendikten sonra "enabled": false ise devre dışı bırakalım
        if rule.get("enabled", True) is False:
            dc_cmd = [
                "powershell",
                "-Command",
                f"Disable-NetFirewallRule -Name '{rule_name}'"
            ]
            subprocess.run(dc_cmd, capture_output=True, text=True)

    def remove_rule(self, rule_name):
        """
        Kuralı isme göre siler.
        """
        ps_cmd = ["powershell", "-Command", f"Remove-NetFirewallRule -Name '{rule_name}'"]
        subprocess.run(ps_cmd, capture_output=True, text=True)

    def update_rule(self, old_rule, new_rule):
        """
        Önce eski kuralı silip sonra yenisini ekliyoruz.
        """
        self.remove_rule(old_rule.get("rule_name", ""))
        self.add_rule(new_rule)




================================================
File: app/routers/auth.py
================================================
from fastapi import APIRouter, HTTPException, status, Depends
from datetime import datetime, timedelta
from passlib.hash import bcrypt
from jose import jwt
from ..config import settings
from ..database import db
from ..schemas import UserCreate, UserLogin, Token
from ..dependencies import get_current_user

auth_router = APIRouter(prefix="/auth", tags=["auth"])

@auth_router.post("/register")
async def register_user(user_in: UserCreate):
    existing = await db["users"].find_one({"username": user_in.username})
    if existing:
        raise HTTPException(status_code=400, detail="Username already taken")

    hashed_pass = bcrypt.hash(user_in.password)
    new_user = {
        "username": user_in.username,
        "hashed_password": hashed_pass,
        "role": "admin",
        "created_at": datetime.utcnow()
    }
    result = await db["users"].insert_one(new_user)
    return {"message": "User created", "user_id": str(result.inserted_id)}

@auth_router.post("/login", response_model=Token)
async def login_user(user_in: UserLogin):
    user = await db["users"].find_one({"username": user_in.username})
    if not user or not bcrypt.verify(user_in.password, user["hashed_password"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {"sub": user["username"], "exp": expire}
    token = jwt.encode(payload, settings.JWT_SECRET, algorithm=settings.JWT_ALGORITHM)
    return {"access_token": token, "token_type": "bearer"}

@auth_router.get("/me")
async def get_me(current_user=Depends(get_current_user)):
    return {
        "username": current_user["username"],
        "role": current_user["role"],
        "created_at": current_user["created_at"]
    }



================================================
File: app/routers/backup.py
================================================
from fastapi import APIRouter, Depends
from ..dependencies import require_admin
from ..database import db

backup_router = APIRouter(prefix="/backup", tags=["backup"])

@backup_router.get("/export")
async def export_config(admin=Depends(require_admin)):
    data = {}
    data["interfaces"] = await db["interfaces"].find({}).to_list(None)
    data["firewall_rules"] = await db["firewall_rules"].find({}).to_list(None)
    data["routes"] = await db["routes"].find({}).to_list(None)
    return data

@backup_router.post("/import")
async def import_config(config_data: dict, admin=Depends(require_admin)):
    await db["interfaces"].delete_many({})
    await db["firewall_rules"].delete_many({})
    await db["routes"].delete_many({})

    if "interfaces" in config_data:
        await db["interfaces"].insert_many(config_data["interfaces"])
    if "firewall_rules" in config_data:
        await db["firewall_rules"].insert_many(config_data["firewall_rules"])
    if "routes" in config_data:
        await db["routes"].insert_many(config_data["routes"])

    return {"message": "Config imported successfully (OS sync not implemented)."}



================================================
File: app/routers/dns.py
================================================
# File: app/routers/dns.py
import os
import platform
import subprocess
import requests
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel

from app.dependencies import require_admin
from app.database import db

dns_router = APIRouter(prefix="/dns", tags=["dns"])


class DomainBlock(BaseModel):
    domain: str
    note: Optional[str] = None
    use_wildcard: bool = True

class AdblockList(BaseModel):
    url: str


def get_conf_path() -> str:
    if platform.system().lower().startswith("win"):
        return r"C:\temp\blocked-domains.conf"
    else:
        return "/tmp/blocked-domains.conf"


def ensure_config_dir():
    conf_path = get_conf_path()
    dir_path = os.path.dirname(conf_path)
    if dir_path and not os.path.exists(dir_path):
        os.makedirs(dir_path, exist_ok=True)


def reload_dns_service():
    sysname = platform.system().lower()
    if sysname.startswith("linux"):
        subprocess.run(["sudo", "systemctl", "reload", "dnsmasq"], capture_output=True, text=True)
    elif sysname.startswith("win"):
        subprocess.run(["ipconfig", "/flushdns"], capture_output=True, text=True)
    else:
        pass


@dns_router.get("/domains")
async def list_blocked_domains(admin=Depends(require_admin)):
    cursor = db["blocked_domains"].find({})
    result = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])  # convert ObjectId to string
        result.append(doc)
    return result


@dns_router.post("/domains")
async def add_blocked_domain(domain_in: DomainBlock, admin=Depends(require_admin)):
    domain_lower = domain_in.domain.strip().lower()
    existing = await db["blocked_domains"].find_one({"domain": domain_lower})
    if existing:
        raise HTTPException(400, detail="Bu domain zaten engelli.")

    doc = {
        "domain": domain_lower,
        "note": domain_in.note or "",
        "use_wildcard": domain_in.use_wildcard,
        "created_at": datetime.utcnow()
    }
    await db["blocked_domains"].insert_one(doc)
    await rewrite_dns_config()
    return {"message": f"Domain engellendi: {domain_lower}"}


@dns_router.delete("/domains/{domain}")
async def remove_blocked_domain(domain: str, admin=Depends(require_admin)):
    domain_lower = domain.strip().lower()
    result = await db["blocked_domains"].delete_one({"domain": domain_lower})
    if result.deleted_count == 0:
        raise HTTPException(404, detail="Bu domain kayıtlı değil.")
    await rewrite_dns_config()
    return {"message": f"Domain silindi: {domain_lower}"}


@dns_router.post("/adblocklist")
async def import_adblock_list(data: AdblockList, admin=Depends(require_admin)):
    """
    Basit bir Adblock liste import örneği.
    """
    try:
        resp = requests.get(data.url, timeout=10)
        if resp.status_code != 200:
            raise HTTPException(400, detail=f"Liste indirilemedi: HTTP {resp.status_code}")
        lines = resp.text.splitlines()
        count_added = 0
        for line in lines:
            line = line.strip().lower()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            dom = parts[-1]
            # Bazı listelerde '0.0.0.0 example.com' formatı olabilir
            if dom.startswith("0.0.0.0") or dom.startswith("127."):
                if len(parts) > 1:
                    dom = parts[1]
            existing = await db["blocked_domains"].find_one({"domain": dom})
            if not existing:
                doc = {
                    "domain": dom,
                    "use_wildcard": False,
                    "note": "Adblock imported",
                    "created_at": datetime.utcnow()
                }
                await db["blocked_domains"].insert_one(doc)
                count_added += 1

        await rewrite_dns_config()
        return {"message": f"Adblock listesi indirildi. {count_added} domain eklendi."}
    except Exception as e:
        raise HTTPException(500, detail=f"Liste indirme hatası: {str(e)}")


@dns_router.post("/doh-block")
async def doh_block(admin=Depends(require_admin)):
    """
    DNS Over HTTPS engellemek için endpoint.
    Şimdilik basit bir mock: "Henüz implemente edilmedi" ya da
    basit firewall kural ekleme vb.
    """
    sysname = platform.system().lower()
    # Örnek: ufak bir mesaj döndürelim
    return {"message": "DNS over HTTPS Engelleme işlemi (örnek). Daha fazla IP ekleme vs. yapılabilir."}


async def rewrite_dns_config():
    ensure_config_dir()
    conf_path = get_conf_path()

    cursor = db["blocked_domains"].find({})
    lines = []
    async for item in cursor:
        d = item["domain"]
        use_wc = item.get("use_wildcard", True)
        lines.append(f"127.0.0.1 {d}\n")
        if use_wc:
            lines.append(f"127.0.0.1 www.{d}\n")
            lines.append(f"127.0.0.1 sub.{d}\n")

    try:
        with open(conf_path, "w", encoding="utf-8") as f:
            f.writelines(lines)
    except Exception as e:
        raise HTTPException(500, detail=f"Config dosyası yazılamadı: {str(e)}")

    reload_dns_service()



================================================
File: app/routers/firewall.py
================================================
# File: app/routers/firewall.py

from fastapi import APIRouter, Depends, HTTPException
from bson import ObjectId
from datetime import datetime
from app.database import db
from app.dependencies import require_admin
from app.firewall_os import add_firewall_rule_os, remove_firewall_rule_os, update_firewall_rule_os

firewall_router = APIRouter(prefix="/firewall", tags=["firewall"])


@firewall_router.get("/rules")
async def list_rules(admin=Depends(require_admin)):
    cursor = db["firewall_rules"].find({})
    results = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        results.append(doc)
    return results


@firewall_router.post("/rules")
async def create_rule(rule_in: dict, admin=Depends(require_admin)):
    """
    Yeni kural ekleme.
    rule_in => {
      "rule_name": str,
      "source_ips": [...],
      "port": int,
      "protocol": "TCP"/"UDP",
      "action": "ALLOW"/"DENY",
      "direction": "IN"/"OUT",
      "profile": "Any"/"Private"/"Public",
      "description": str,
      "enabled": bool,
      ...
    }
    """
    try:
        add_firewall_rule_os(rule_in)  # Windows -> WinFirewall, Linux -> LinuxFirewall
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

    doc = rule_in
    doc["created_at"] = datetime.utcnow()
    result = await db["firewall_rules"].insert_one(doc)
    doc["_id"] = str(result.inserted_id)
    return {"message": "Kural eklendi", "data": doc}


@firewall_router.put("/rules/{rule_id}")
async def update_rule(rule_id: str, rule_in: dict, admin=Depends(require_admin)):
    try:
        obj_id = ObjectId(rule_id)
    except:
        raise HTTPException(400, "GeÃ§ersiz rule_id")

    old_doc = await db["firewall_rules"].find_one({"_id": obj_id})
    if not old_doc:
        raise HTTPException(404, "Kural bulunamadÄ±")

    try:
        update_firewall_rule_os(old_doc, rule_in)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

    rule_in["updated_at"] = datetime.utcnow()
    await db["firewall_rules"].update_one({"_id": obj_id}, {"$set": rule_in})

    return {"message": "Kural gÃ¼ncellendi"}


@firewall_router.delete("/rules/{rule_id}")
async def delete_rule(rule_id: str, admin=Depends(require_admin)):
    try:
        obj_id = ObjectId(rule_id)
    except:
        raise HTTPException(400, "GeÃ§ersiz rule_id")

    old_doc = await db["firewall_rules"].find_one({"_id": obj_id})
    if not old_doc:
        raise HTTPException(404, "Kural yok")

    remove_firewall_rule_os(old_doc["rule_name"])
    await db["firewall_rules"].delete_one({"_id": obj_id})

    return {"message": "Kural silindi."}



================================================
File: app/routers/firewall_groups.py
================================================
import platform
import subprocess
from datetime import datetime
from bson import ObjectId
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from typing import Optional

from app.database import db
from app.dependencies import require_admin
from app.routers.firewall import remove_firewall_rule_os, add_firewall_rule_os

firewall_groups_router = APIRouter(
    prefix="/firewall/groups",
    tags=["firewall-groups"]
)

class FirewallGroupModel(BaseModel):
    group_name: str
    description: Optional[str] = None

@firewall_groups_router.get("/")
async def list_groups(admin=Depends(require_admin)):
    cursor = db["firewall_groups"].find({})
    groups = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        groups.append(doc)
    return groups

@firewall_groups_router.post("/")
async def create_group(data: FirewallGroupModel, admin=Depends(require_admin)):
    group_doc = {
        "group_name": data.group_name,
        "description": data.description or "",
        "created_at": datetime.utcnow()
    }
    result = await db["firewall_groups"].insert_one(group_doc)
    return {"message": "Grup oluÅŸturuldu", "group_id": str(result.inserted_id)}

@firewall_groups_router.delete("/{group_id}")
async def delete_group(group_id: str, admin=Depends(require_admin)):
    try:
        obj_id = ObjectId(group_id)
    except:
        raise HTTPException(400, "GeÃ§ersiz group_id (ObjectId deÄŸil)")

    group_doc = await db["firewall_groups"].find_one({"_id": obj_id})
    if not group_doc:
        raise HTTPException(404, "Grup bulunamadÄ±")

    await db["firewall_groups"].delete_one({"_id": obj_id})
    return {"message": f"Grup '{group_doc['group_name']}' silindi."}

@firewall_groups_router.patch("/{group_id}/enable")
async def enable_disable_group(group_id: str, enable: bool, admin=Depends(require_admin)):
    try:
        obj_id = ObjectId(group_id)
    except:
        raise HTTPException(400, "GeÃ§ersiz group_id (ObjectId deÄŸil)")

    group_doc = await db["firewall_groups"].find_one({"_id": obj_id})
    if not group_doc:
        raise HTTPException(404, "Grup kaydÄ± yok")

    cursor = db["firewall_rules"].find({"group_id": group_id})
    rules_in_group = []
    async for rule_doc in cursor:
        rules_in_group.append(rule_doc)

    for rdoc in rules_in_group:
        remove_firewall_rule_os(rdoc["rule_name"])

        await db["firewall_rules"].update_one(
            {"_id": rdoc["_id"]},
            {"$set": {"enabled": enable}}
        )

        if enable:
            tmp_rule = {
                "rule_name": rdoc["rule_name"],
                "source_ips": rdoc.get("source_ips", []),
                "port": rdoc.get("port"),
                "protocol": rdoc.get("protocol", "TCP"),
                "action": rdoc.get("action", "ALLOW"),
                "direction": rdoc.get("direction", "IN"),
                "profile": rdoc.get("profile", "Any"),
                "description": rdoc.get("description", ""),
                "enabled": True
            }
            add_firewall_rule_os(tmp_rule)

    msg = "Grup kurallarÄ± etkinleÅŸtirildi." if enable else "Grup kurallarÄ± pasifleÅŸtirildi."
    return {"message": msg}

@firewall_groups_router.get("/{group_id}/rules")
async def list_group_rules(group_id: str, admin=Depends(require_admin)):
    try:
        obj_id = ObjectId(group_id)
    except:
        raise HTTPException(400, "GeÃ§ersiz group_id")

    group_doc = await db["firewall_groups"].find_one({"_id": obj_id})
    if not group_doc:
        raise HTTPException(404, "Grup bulunamadÄ±.")

    cursor = db["firewall_rules"].find({"group_id": group_id})
    arr = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        arr.append(doc)
    return arr



================================================
File: app/routers/layer7_inspect.py
================================================
import threading
from scapy.all import sniff, TCP

def packet_callback(pkt):
    if pkt.haslayer(TCP):
        payload = bytes(pkt[TCP].payload)
        # Ã–rnek: HTTP flood tespiti, SSH brute force vs.
        # Uygun bulursak DB'ye log, firewall rule ekleme vs.

def start_sniffer():
    sniff(filter="tcp", prn=packet_callback, store=0)

def start_layer7_inspect():
    t = threading.Thread(target=start_sniffer, daemon=True)
    t.start()



================================================
File: app/routers/logs.py
================================================
from fastapi import APIRouter, Depends
from ..dependencies import require_admin
from ..database import db

logs_router = APIRouter(prefix="/logs", tags=["logs"])

@logs_router.get("/")
async def list_logs(level: str = None, ip: str = None, admin=Depends(require_admin)):
    query = {}
    if level:
        query["level"] = level
    if ip:
        query["source_ip"] = ip

    cursor = db["logs"].find(query)
    logs = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        logs.append(doc)
    return logs

@logs_router.get("/blocked")
async def list_blocked_packets(admin=Depends(require_admin)):
    cursor = db["blocked_packets"].find({}).sort("timestamp", -1)
    packets = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        packets.append(doc)
    return packets

@logs_router.get("/alerts")
async def list_alerts(admin=Depends(require_admin)):
    cursor = db["alerts"].find({}).sort("timestamp", -1)
    alerts = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        alerts.append(doc)
    return alerts



================================================
File: app/routers/nat.py
================================================
import subprocess
import platform
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import Optional
from app.dependencies import require_admin
from app.database import db

nat_router = APIRouter(prefix="/nat", tags=["nat"])

class NatConfig(BaseModel):
    enabled: bool
    wan: Optional[str] = None  # WAN interface ismi (internet aldÄ±ÄŸÄ±)
    lan: Optional[str] = None  # LAN interface ismi (ICS paylaÅŸtÄ±rÄ±lacak aÄŸ)

@nat_router.get("")
async def get_nat_config(admin=Depends(require_admin)):
    """
    NAT (ICS) ayarlarÄ±nÄ± DB'den okur.
    Ã–rnek dÃ¶nÃ¼ÅŸ:
    {
      "enabled": false,
      "wan": "",
      "lan": ""
    }
    """
    doc = await db["nat_config"].find_one({"_id": "main"})
    if not doc:
        return {"enabled": False, "wan": "", "lan": ""}
    return {
        "enabled": doc.get("enabled", False),
        "wan": doc.get("wan", ""),
        "lan": doc.get("lan", "")
    }

@nat_router.patch("")
async def update_nat_config(cfg: NatConfig, admin=Depends(require_admin)):
    """
    NAT ICS ayarlarÄ±nÄ± gÃ¼nceller (yalnÄ±zca Windows'ta).
    1) DB'ye kaydeder
    2) Mevcut tÃ¼m ICS paylaÅŸÄ±mÄ±nÄ± disable eder
    3) enabled=True ise WAN->Internet, LAN->Home ICS aktif etmeye Ã§alÄ±ÅŸÄ±r
    """
    # 1) Windows deÄŸilse hata
    if platform.system().lower() != "windows":
        raise HTTPException(
            status_code=400,
            detail="NAT ICS sadece Windows ortamÄ±nda uygulanÄ±r."
        )

    # 2) WAN ve LAN farklÄ± olmalÄ±
    if cfg.enabled and cfg.wan == cfg.lan:
        raise HTTPException(
            status_code=400,
            detail="WAN ve LAN aynÄ± arayÃ¼z olamaz. LÃ¼tfen farklÄ± arayÃ¼zler seÃ§in."
        )

    # 3) DB'ye kaydet
    await db["nat_config"].update_one(
        {"_id": "main"},
        {
            "$set": {
                "enabled": cfg.enabled,
                "wan": cfg.wan or "",
                "lan": cfg.lan or ""
            }
        },
        upsert=True
    )

    # 4) ICS devre dÄ±ÅŸÄ±
    try:
        _disable_ics_powershell()  # Ã–nce PowerShell ICS kapatma dene
    except ICSCmdletNotFound:
        # EÄŸer cmdlet yoksa netsh/servis fallback
        _disable_ics_netsh()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

    # 5) ICS etkinleÅŸtirme (cfg.enabled=True ise)
    if cfg.enabled:
        try:
            _enable_ics(cfg.wan, cfg.lan)  # PowerShell ICS
        except ICSCmdletNotFound:
            # Tekrar fallback netsh ICS
            try:
                _enable_ics_netsh(cfg.wan, cfg.lan)
            except Exception as e2:
                raise HTTPException(status_code=500, detail=str(e2))
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))

    return {"message": "ICS NAT yapÄ±landÄ±rmasÄ± gÃ¼ncellendi."}

# ------------------------------------------------
# YardÄ±mcÄ± sÄ±nÄ±f ve fonksiyonlar
# ------------------------------------------------

class ICSCmdletNotFound(Exception):
    """
    PowerShell ICS cmdlet'lerinin (Get-NetConnectionSharing / Enable-NetConnectionSharing)
    bulunmadÄ±ÄŸÄ±nÄ± belirten Ã¶zel exception.
    """

def _disable_ics_powershell():
    """
    PowerShell ICS cmdlet'leriyle ICS paylaÅŸÄ±mÄ±nÄ± kapatÄ±r.
    EÄŸer 'Get-NetConnectionSharing' / 'Disable-NetConnectionSharing' yoksa ICSCmdletNotFound fÄ±rlatÄ±r.
    """
    ps_script = r"""
    try {
      Get-NetConnectionSharing | ForEach-Object {
        Disable-NetConnectionSharing -ConnectionName $_.ConnectionName
      }
    }
    catch {
      throw $_
    }
    """
    cmd = ["powershell", "-Command", ps_script]
    res = subprocess.run(cmd, capture_output=True, text=True)
    # stderr'i None gelirse boÅŸ string verelim:
    stderr_text = res.stderr or ""

    if res.returncode != 0:
        if "CommandNotFoundException" in stderr_text:
            # Bu, ICS cmdletlerinin bulunmadÄ±ÄŸÄ±na iÅŸaret
            raise ICSCmdletNotFound("PowerShell ICS cmdlet'leri bulunamadÄ±.")
        else:
            # DiÄŸer hata
            raise RuntimeError(stderr_text.strip())

def _disable_ics_netsh():
    """
    Netsh ile ICS kapatma.
    Windows ICS servisi 'SharedAccess' adÄ±yla bilinir.
    AÅŸaÄŸÄ±daki komutlar sÄ±rasÄ±yla:
      - "sc config SharedAccess start= disabled"
      - "net stop SharedAccess"
    ile servisi durdurup devre dÄ±ÅŸÄ± bÄ±rakmaya Ã§alÄ±ÅŸÄ±r.
    """
    cmds = [
        ["sc", "config", "SharedAccess", "start=", "disabled"],
        ["net", "stop", "SharedAccess"]
    ]
    for c in cmds:
        proc = subprocess.run(c, capture_output=True, text=True)
        stderr_text = proc.stderr or ""
        # Hata Ã§Ä±karsa, loglama yapmak isteyebilirsiniz.
        # Ama burada "already stopped" vb. durumlar normal sayÄ±labilir.

def _enable_ics(wan_iface: str, lan_iface: str):
    """
    PowerShell ICS cmdlet'leriyle WAN->Internet, LAN->Home paylaÅŸÄ±mÄ±.
    1) WAN arayÃ¼zÃ¼nÃ¼ "Internet" modunda paylaÅŸma
    2) LAN arayÃ¼zÃ¼nÃ¼ "Home" modunda paylaÅŸma
    """
    # 1) WAN -> Internet
    ps_script_wan = f"""
    try {{
      Enable-NetConnectionSharing -ConnectionName '{wan_iface}' -SharingMode Internet
    }}
    catch {{
      throw $_
    }}
    """
    cmd_wan = ["powershell", "-Command", ps_script_wan]
    res_wan = subprocess.run(cmd_wan, capture_output=True, text=True)
    stderr_wan = res_wan.stderr or ""
    if res_wan.returncode != 0:
        if "CommandNotFoundException" in stderr_wan:
            # ICS cmdleti yok
            raise ICSCmdletNotFound("Enable-NetConnectionSharing bulunamadÄ±.")
        else:
            raise RuntimeError(stderr_wan.strip())

    # 2) LAN -> Home
    ps_script_lan = f"""
    try {{
      Enable-NetConnectionSharing -ConnectionName '{lan_iface}' -SharingMode Home
    }}
    catch {{
      throw $_
    }}
    """
    cmd_lan = ["powershell", "-Command", ps_script_lan]
    res_lan = subprocess.run(cmd_lan, capture_output=True, text=True)
    stderr_lan = res_lan.stderr or ""
    if res_lan.returncode != 0:
        if "CommandNotFoundException" in stderr_lan:
            raise ICSCmdletNotFound("Enable-NetConnectionSharing yok.")
        else:
            raise RuntimeError(stderr_lan.strip())

def _enable_ics_netsh(wan_iface: str, lan_iface: str):
    """
    Netsh fallback (basit ICS):
      1) SharedAccess servisini 'auto' yap
      2) 'net start SharedAccess' ile servisi baÅŸlat
      3) netsh ICS parametreleri ile tam paylaÅŸtÄ±rma (bazÄ± sÃ¼rÃ¼mlerde kÄ±sÄ±tlÄ±)
    """
    # 1) 'SharedAccess' servisini otomatik ve start
    cmds = [
        ["sc", "config", "SharedAccess", "start=", "auto"],
        ["net", "start", "SharedAccess"]
    ]
    for c in cmds:
        p = subprocess.run(c, capture_output=True, text=True)
        stderr_text = p.stderr or ""
        if p.returncode != 0:
            # "already running" vb. olabilir, normal sayabiliriz
            # ama gene de hata fÄ±rlatalÄ±m ki log gÃ¶rÃ¼lsÃ¼n
            if "already been started" in stderr_text.lower():
                # bu hata normal
                continue
            raise RuntimeError(f"Command '{' '.join(c)}' failed: {stderr_text.strip()}")

    # 2) ICS'yi netsh parametreleriyle tam ayarlamak zordur.
    # Burada opsiyonel ek ayarlar yazabilirsiniz.
    #
    # Ã–rneÄŸin:
    # netsh routing ip install
    # netsh routing ip nat install
    # netsh routing ip nat add interface "WAN" full
    # netsh routing ip nat add interface "LAN" private
    #
    # Fakat ICS devreye girdiÄŸinde bu NAT ayarlarÄ± conflict yaratabilir.
    # Deneysel olarak ekleyebilirsiniz.
    # Yine de ICS devredeyken 'routing ip nat' komutlarÄ± her zaman Ã§alÄ±ÅŸmayabiliyor.



================================================
File: app/routers/network.py
================================================
# File: app/routers/network.py
import subprocess
import platform
import ctypes
from datetime import datetime, timezone
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import Optional

from app.dependencies import require_admin
from app.database import db

network_router = APIRouter(prefix="/network", tags=["network"])

# ----------------------------- MODELS --------------------------------- #
class InterfaceConfig(BaseModel):
    interface_name: str
    ip_mode: str = "static"          # "static" | "dhcp"
    ip_address: Optional[str] = None
    subnet_mask: Optional[str] = None
    gateway: Optional[str] = None
    dns_primary: Optional[str] = None
    dns_secondary: Optional[str] = None
    admin_enabled: bool = True
    mtu: Optional[int] = None
    vlan_id: Optional[int] = None
# ---------------------------------------------------------------------- #

# ----------------------------- HELPERS -------------------------------- #
def is_windows_admin() -> bool:
    if platform.system().lower() != "windows":
        return True            # Linuxâ€™ta sudo ile Ã§alÄ±ÅŸtÄ±rÄ±ldÄ±ÄŸÄ± varsay.
    try:
        return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except Exception:          # noqa: S110
        return False

def run(cmd: list[str]) -> subprocess.CompletedProcess:         # kÃ¼Ã§Ã¼k yardÄ±mcÄ±
    return subprocess.run(cmd, capture_output=True, text=True)

def get_interface_admin_state(name: str) -> str:
    """
    netsh ile arayÃ¼zÃ¼n Enabled/Disabled bilgisini getirir.
    "" dÃ¶nerse bilinmiyor.
    """
    res = run(["netsh", "interface", "show", "interface", f"name={name}"])
    if res.returncode != 0:
        return ""
    for line in res.stdout.splitlines():
        parts = line.split(None, 3)
        # Expected format: Admin  State  Type  Interface Name
        if len(parts) == 4 and parts[3].strip() == name:
            return parts[0].strip()       # Enabled | Disabled
    return ""

def parse_netsh_error(stderr_text: str) -> str:
    msg_lower = (stderr_text or "").lower()
    if "access is denied" in msg_lower:
        return "YÃ¶netici izni gerekli (Run as Administrator)."
    if "not found" in msg_lower or "no matching interface" in msg_lower:
        return "ArayÃ¼z ismi bulunamadÄ± ('netsh interface show interface' ile kontrol edin)."
    if "media disconnected" in msg_lower:
        return "ArayÃ¼z baÄŸlantÄ±sÄ±z (kablo/Wi-Fi kapalÄ±?)."
    if "object is already in use" in msg_lower or "duplicate" in msg_lower:
        return "IP adresi baÅŸka bir cihazda kullanÄ±mda (IP Ã§akÄ±ÅŸmasÄ±)."
    if "dhcp" in msg_lower and "fail" in msg_lower:
        return "DHCP sunucusuna ulaÅŸÄ±lamadÄ± veya zaman aÅŸÄ±mÄ±."
    if msg_lower.strip() == "":
        # netsh bazen stderrâ€™i boÅŸ, exit codeâ€™u 1 dÃ¶ndÃ¼rÃ¼r
        return "Netsh komutu baÅŸarÄ±sÄ±z; ayrÄ±ntÄ± yok â€“ bÃ¼yÃ¼k olasÄ±lÄ±kla YÃ¶netici izni gerekir."
    return stderr_text.strip()
# ---------------------------------------------------------------------- #

# ============================= ENDPOINTS ============================== #
@network_router.get("/interfaces")
async def list_interfaces(admin=Depends(require_admin)):
    docs = await db["interfaces"].find({}).to_list(None)
    for d in docs:
        d["_id"] = str(d["_id"])

    if platform.system().lower().startswith("win"):
        res = run(["netsh", "interface", "show", "interface"])
        lines = res.stdout.splitlines()
        for doc in docs:
            doc["link_state"] = "unknown"
            doc["admin_state"] = "unknown"
            for line in lines:
                parts = line.split(None, 3)
                if len(parts) == 4 and parts[3] == doc["interface_name"]:
                    doc["admin_state"] = parts[0]
                    doc["link_state"] = parts[1]
                    break
    else:
        for d in docs:
            d["link_state"] = "unknown"
            d["admin_state"] = "unknown"

    return docs


@network_router.post("/interfaces")
async def create_interface(config: InterfaceConfig, admin=Depends(require_admin)):
    if platform.system().lower() != "windows":
        raise HTTPException(400, "Bu endpoint yalnÄ±zca Windows altÄ±nda kullanÄ±labilir.")

    if not is_windows_admin():
        raise HTTPException(
            400,
            "Bu iÅŸlemi yapmak iÃ§in uygulamayÄ± **YÃ¶netici (Run as Administrator)** olarak Ã§alÄ±ÅŸtÄ±rÄ±n."
        )

    try:
        # -------- 1) admin up/down (yalnÄ±zca gerekliyse) -------- #
        current_state = get_interface_admin_state(config.interface_name)
        desired_state = "Enabled" if config.admin_enabled else "Disabled"
        if current_state and current_state.lower() == desired_state.lower():
            pass  # zaten istenen durumda, netsh Ã§aÄŸÄ±rmaya gerek yok
        else:
            adm_cmd = [
                "netsh", "interface", "set", "interface",
                f"name={config.interface_name}",
                f"admin={'enabled' if config.admin_enabled else 'disabled'}"
            ]
            res_adm = run(adm_cmd)
            if res_adm.returncode != 0:
                raise HTTPException(400, f"Admin up/down hatasÄ±: {parse_netsh_error(res_adm.stderr)}")

        # -------- 2) IP MODE -------- #
        if config.ip_mode.lower() == "dhcp":
            res_ip = run([
                "netsh", "interface", "ip", "set", "address",
                f"name={config.interface_name}", "source=dhcp"
            ])
            if res_ip.returncode != 0:
                raise HTTPException(400, f"DHCP hatasÄ±: {parse_netsh_error(res_ip.stderr)}")

            res_dns = run([
                "netsh", "interface", "ip", "set", "dns",
                f"name={config.interface_name}", "source=dhcp"
            ])
            if res_dns.returncode != 0:
                raise HTTPException(400, f"DHCP-DNS hatasÄ±: {parse_netsh_error(res_dns.stderr)}")

        else:  # STATIC
            if not config.ip_address or not config.subnet_mask:
                raise HTTPException(400, "Statik modda IP ve Subnet zorunludur.")

            res_static = run([
                "netsh", "interface", "ip", "set", "address",
                f"name={config.interface_name}", "static",
                config.ip_address, config.subnet_mask,
                config.gateway if config.gateway else "none"
            ])
            if res_static.returncode != 0:
                raise HTTPException(400, f"IP ayarÄ± hatasÄ±: {parse_netsh_error(res_static.stderr)}")

            # DNS birincil / ikincil
            if config.dns_primary:
                res_dns1 = run([
                    "netsh", "interface", "ip", "set", "dns",
                    f"name={config.interface_name}", "static", config.dns_primary
                ])
                if res_dns1.returncode != 0:
                    raise HTTPException(400, f"DNS-1 hatasÄ±: {parse_netsh_error(res_dns1.stderr)}")

            if config.dns_secondary:
                res_dns2 = run([
                    "netsh", "interface", "ip", "add", "dns",
                    f"name={config.interface_name}", config.dns_secondary, "index=2"
                ])
                if res_dns2.returncode != 0:
                    raise HTTPException(400, f"DNS-2 hatasÄ±: {parse_netsh_error(res_dns2.stderr)}")

        # -------- 3) MTU -------- #
        if config.mtu:
            res_mtu = run([
                "netsh", "interface", "ipv4", "set", "subinterface",
                config.interface_name, f"mtu={config.mtu}", "store=persistent"
            ])
            if res_mtu.returncode != 0:
                raise HTTPException(400, f"MTU hatasÄ±: {parse_netsh_error(res_mtu.stderr)}")

        # -------- 4) DB kayÄ±t / response -------- #
        doc = {
            "interface_name": config.interface_name,
            "ip_mode": config.ip_mode.lower(),
            "ip_address": config.ip_address,
            "subnet_mask": config.subnet_mask,
            "gateway": config.gateway,
            "dns_primary": config.dns_primary,
            "dns_secondary": config.dns_secondary,
            "admin_enabled": config.admin_enabled,
            "mtu": config.mtu,
            "vlan_id": config.vlan_id,
            "updated_at": datetime.now(timezone.utc).isoformat()
        }
        await db["interfaces"].update_one(
            {"interface_name": config.interface_name},
            {"$set": doc},
            upsert=True
        )
        return {"message": "Interface kaydedildi", "data": doc}

    except HTTPException:
        raise
    except Exception as exc:
        raise HTTPException(500, str(exc)) from exc


@network_router.put("/interfaces/{iface_name}")
async def update_interface(iface_name: str, config: InterfaceConfig, admin=Depends(require_admin)):
    # PUT endpoint mantÄ±ÄŸÄ± POST ile neredeyse aynÄ±; tekrar yazmamak iÃ§in
    # kÃ¼Ã§Ã¼k farklarla aynÄ± fonksiyonu kullanmak da mÃ¼mkÃ¼ndÃ¼.
    return await create_interface(config, admin)   # noqa: WPS331


@network_router.delete("/interfaces/{iface_name}")
async def delete_interface(iface_name: str, admin=Depends(require_admin)):
    doc = await db["interfaces"].find_one({"interface_name": iface_name})
    if not doc:
        raise HTTPException(404, "ArayÃ¼z kaydÄ± bulunamadÄ±")

    await db["interfaces"].delete_one({"interface_name": iface_name})
    return {"message": f"{iface_name} arayÃ¼zÃ¼ DB kaydÄ±ndan silindi."}



================================================
File: app/routers/routes.py
================================================
# File: app/routers/routes.py
# Path: app/routers/routes.py

import subprocess
import platform
import re
import asyncio
from datetime import datetime, timezone
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, Field
from typing import Optional

from ..dependencies import require_admin
from ..database import db

route_router = APIRouter(prefix="/routes", tags=["routes"])

# =========== MODEL / SCHEMA ===========
class RouteConfig(BaseModel):
    destination: str
    mask: str
    gateway: str
    metric: int = Field(1, ge=1, le=9999)
    enabled: bool = True
    interface_name: Optional[str] = None  # Windows "Ethernet", Linux "eth0" vb.
    mode: str = "static"  # "dhcp" veya "static"
    failover: bool = False  # opsiyonel

# Basit IP kontrolÃ¼ (regex)
ip_pattern = re.compile(r"^((25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(25[0-5]|2[0-4]\d|[01]?\d?\d)$")

def is_valid_ip(ip: str) -> bool:
    return bool(ip_pattern.match(ip))

def validate_route_fields(route: RouteConfig):
    if not is_valid_ip(route.destination):
        raise HTTPException(400, detail="Hedef IP formatÄ± geÃ§ersiz.")
    if not is_valid_ip(route.mask):
        raise HTTPException(400, detail="Subnet Mask formatÄ± geÃ§ersiz.")
    if not is_valid_ip(route.gateway):
        raise HTTPException(400, detail="Gateway IP formatÄ± geÃ§ersiz.")

def parse_netsh_error(stderr_text: str) -> str:
    text_lower = stderr_text.lower()
    if "already in use" in text_lower or "duplicate" in text_lower:
        return "IP Ã§akÄ±ÅŸmasÄ± veya rota Ã§akÄ±ÅŸmasÄ± tespit edildi."
    if "dhcp" in text_lower and "fail" in text_lower:
        return "DHCP sunucusuna ulaÅŸÄ±lamadÄ± (DHCP config hatasÄ±)."
    return stderr_text.strip()

async def failover_watchdog_task():
    """
    Asenkron failover senaryosu (opsiyonel).
    failover=true, enabled=true olan rotalara gateway ping atar,
    yanÄ±t yoksa remove_route ile siler.
    """
    while True:
        cursor = db["routes"].find({"failover": True, "enabled": True})
        async for rt in cursor:
            gw_ip = rt.get("gateway")
            if not gw_ip:
                continue
            # Ping
            if platform.system().lower().startswith("win"):
                cmd_ping = ["ping", "-n", "1", "-w", "200", gw_ip]
            else:
                cmd_ping = ["ping", "-c", "1", "-W", "1", gw_ip]

            result = subprocess.run(cmd_ping, capture_output=True, text=True)
            if result.returncode != 0:
                try:
                    remove_route(rt)
                    print(f"[Failover] Gateway yanÄ±t vermiyor, rota silindi: {rt['_id']}")
                except Exception as exc:
                    print(f"[Failover] remove_route hatasÄ±: {exc}")

        await asyncio.sleep(10)  # 10 saniyede bir kontrol

@route_router.on_event("startup")
async def start_failover_watchdog():
    asyncio.create_task(failover_watchdog_task())

@route_router.get("/")
async def list_routes(admin=Depends(require_admin)):
    routes_list = []
    cursor = db["routes"].find({})
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        routes_list.append(doc)
    return routes_list

@route_router.post("/")
async def create_route(route_in: RouteConfig, admin=Depends(require_admin)):
    validate_route_fields(route_in)
    add_route_os(route_in)

    doc = route_in.dict()
    doc["created_at"] = datetime.now(timezone.utc).isoformat()
    result = await db["routes"].insert_one(doc)
    doc["_id"] = str(result.inserted_id)
    return {"message": "Rota eklendi", "data": doc}

@route_router.delete("/{route_id}")
async def delete_route(route_id: str, admin=Depends(require_admin)):
    old_doc = await db["routes"].find_one({"_id": route_id})
    if not old_doc:
        raise HTTPException(404, "Rota bulunamadÄ±")

    remove_route(old_doc)
    await db["routes"].delete_one({"_id": route_id})
    return {"message": "Rota silindi"}

@route_router.put("/{route_id}")
async def update_route(route_id: str, route_in: RouteConfig, admin=Depends(require_admin)):
    old_doc = await db["routes"].find_one({"_id": route_id})
    if not old_doc:
        raise HTTPException(404, "Rota bulunamadÄ±")

    # Eskiyi sil
    remove_route(old_doc)
    # Yeni ekle
    validate_route_fields(route_in)
    add_route_os(route_in)

    updated_doc = route_in.dict()
    updated_doc["updated_at"] = datetime.now(timezone.utc).isoformat()
    await db["routes"].update_one({"_id": route_id}, {"$set": updated_doc})
    return {"message": "Rota gÃ¼ncellendi", "data": updated_doc}

def mask_to_cidr(mask_str: str) -> int:
    return sum(bin(int(octet)).count("1") for octet in mask_str.split("."))

def remove_route(rt_doc):
    if not rt_doc.get("destination") or not rt_doc.get("mask"):
        return
    sysname = platform.system().lower()
    if sysname.startswith("win"):
        cmd = [
            "netsh","interface","ipv4","delete","route",
            rt_doc["destination"], rt_doc["mask"]
        ]
        if rt_doc.get("interface_name"):
            cmd.append(rt_doc["interface_name"])
        subprocess.run(cmd, capture_output=True, text=True)
    else:
        cidr = mask_to_cidr(rt_doc["mask"])
        ip_cmd = [
            "ip","route","del",
            f"{rt_doc['destination']}/{cidr}",
            "via", rt_doc["gateway"]
        ]
        if rt_doc.get("interface_name"):
            ip_cmd.extend(["dev", rt_doc["interface_name"]])
        subprocess.run(ip_cmd, capture_output=True, text=True)

def add_route_os(route_in: RouteConfig):
    if route_in.mode.lower() == "dhcp":
        # Gelecekte DHCP route vs.
        raise HTTPException(501, "DHCP route henÃ¼z implemente edilmedi.")

    sysname = platform.system().lower()
    if sysname.startswith("win"):
        netsh_cmd = [
            "netsh","interface","ipv4","add","route",
            route_in.destination, route_in.mask
        ]
        if route_in.interface_name:
            netsh_cmd.append(route_in.interface_name)
        netsh_cmd.extend([
            route_in.gateway,
            f"metric={route_in.metric}",
            "store=persistent"
        ])
        res = subprocess.run(netsh_cmd, capture_output=True, text=True)
        if res.returncode != 0:
            raise HTTPException(
                400,
                detail=f"Windows route ekleme hatasÄ±: {parse_netsh_error(res.stderr)}"
            )
    else:
        cidr = mask_to_cidr(route_in.mask)
        ip_cmd = [
            "ip","route","add",
            f"{route_in.destination}/{cidr}",
            "via", route_in.gateway,
            "metric", str(route_in.metric)
        ]
        if route_in.interface_name:
            ip_cmd.extend(["dev", route_in.interface_name])
        res = subprocess.run(ip_cmd, capture_output=True, text=True)
        if res.returncode != 0:
            raise HTTPException(
                400,
                detail=f"Linux route ekleme hatasÄ±: {res.stderr.strip()}"
            )



================================================
File: app/routers/status.py
================================================
import psutil
import time
from fastapi import APIRouter, Depends
from ..dependencies import get_current_user

status_router = APIRouter(prefix="/status", tags=["status"])

@status_router.get("/dashboard")
async def dashboard_info(user=Depends(get_current_user)):
    cpu_percent = psutil.cpu_percent(interval=0.1)
    mem = psutil.virtual_memory()
    uptime = time.time() - psutil.boot_time()
    return {
        "cpu_percent": cpu_percent,
        "memory_percent": mem.percent,
        "uptime_seconds": int(uptime)
    }



